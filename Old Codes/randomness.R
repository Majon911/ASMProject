# -*- coding: utf-8 -*-
"""network_randomness.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15Ax-KXQ5duG_WEVRQ2qZB5YdXwNZWqXs

Would you say that any of the three networks was randomly generated? Why? If not what type of network are they then? What may that imply with respect to the law firm, the way they work, the way people behave or relate to each other?
"""

install.packages(c('igraph','ggplot2','ggraph'))

install.packages('igraph')

library(igraph)
library(ggplot2)
library(ggraph)

install.packages('networkx')

advice_network <- read_graph("advice.gml", format = "gml")
friend_network <- read_graph("friend.gml", format = "gml")
learn_advice_network <- read_graph("learn_advice.gml", format = "gml")
work_network <- read_graph("work.gml", format = "gml")

"""Identifying whether the three networks are direct or undirected which will be useful to know, to perform community detection later on"""

# advice_network

if (is_directed(advice_network)) {
  print("The network is directed")
} else {
  print("The network is undirected")
}

#friend_network

if (is_directed(friend_network)) {
  print("The network is directed")
} else {
  print("The network is undirected")
}

#learn_advice_network

if (is_directed(learn_advice_network)) {
  print("The network is directed")
} else {
  print("The network is undirected")
}

# node attributes
cat("Node attributes:\n")
print(V(advice_network))
cat("Node attributes:\n")
print(V(friend_network))
cat("Node attributes:\n")
print(V(learn_advice_network))
cat("Node attributes:\n")
print(V(work_network))

# edge attributes
cat("\nEdge attributes:\n")
print(E(advice_network))
cat("\nEdge attributes:\n")
print(E(friend_network))
cat("\nEdge attributes:\n")
print(E(learn_advice_network))
cat("\nEdge attributes:\n")
print(E(work_network))

# Neither the nodes or edges have attributes

"""Genrating 3 random networks with the same structure of the empirical networks with the same number of N using the Erdős-Rényi (ER) model"""

random_advice <- erdos.renyi.game(vcount(advice_network), ecount(advice_network)/choose(vcount(advice_network), 2))
random_friend <- erdos.renyi.game(vcount(friend_network), ecount(friend_network)/choose(vcount(friend_network), 2))
random_learn_advice <- erdos.renyi.game(vcount(learn_advice_network), ecount(learn_advice_network)/choose(vcount(learn_advice_network), 2))
random_work <- erdos.renyi.game(vcount(work_network), ecount(work_network)/choose(vcount(work_network), 2))

"""Comparing the statistics of the three networks with their respective random networks"""

# Degree distribution
# advice_network

print('average degree of the networks')

degree_dist_advice <- mean(degree(advice_network))
degree_dist_random_advice <- mean(degree(random_advice))
print(degree_dist_advice)
print(degree_dist_random_advice)

# friend network

degree_dist_friend <- mean(degree(friend_network))
degree_dist_random_friend <- mean(degree(random_friend))
print(degree_dist_friend)
print(degree_dist_random_friend)

# work network

degree_dist_work <- mean(degree(work_network))
degree_dist_random_work <- mean(degree(random_work))
print(degree_dist_work)
print(degree_dist_random_work)

# Clustering coefficients
#advice network


print("Clustering coefficients")
cc_advice <- transitivity(advice_network)
cc_random_advice <- transitivity(random_advice)
print(cc_advice)
print(cc_random_advice)


#friend network
cc_friend <- transitivity(friend_network)
cc_random_friend <- transitivity(random_friend)
print(cc_friend)
print(cc_random_friend)


# work network
cc_work <- transitivity(work_network)
cc_random_work <- transitivity(random_advice)
print(cc_work)
print(cc_random_work)

#average path lenght

print('average path lenghts')

apl_friend <- average.path.length(friend_network)
apl_random_friend <- average.path.length(random_friend)
print(apl_friend)
print(apl_random_friend)

apl_work <- average.path.length(work_network)
apl_random_work <- average.path.length(random_work)
print(apl_work)
print(apl_random_work)

apl_advice <- average.path.length(advice_network)
apl_random_advice <- average.path.length(random_advice)
print(apl_advice)
print(apl_random_advice)

"""Community detection

- To perform community detection using the louvain algorithm, the networks have to be converted to undirected which may result in an information loss with will be expanded on in the report
"""

# advice network

# Converting directed graph to undirected # may result in an information loss
advice_network_undirected <- as.undirected(advice_network, mode = "mutual")  # considering mutual edges

# Louvain method
community_louvain <- cluster_louvain(advice_network_undirected)
plot(community_louvain, advice_network_undirected)

# friend network

# Converting directed graph to undirected
friend_network_undirected <- as.undirected(friend_network, mode = "mutual")  # considering mutual edges

#  Louvain method
community_louvain <- cluster_louvain(friend_network_undirected)
plot(community_louvain, friend_network_undirected)

# work network
# Converting directed graph to undirected
work_network_undirected <- as.undirected(work_network, mode = "mutual")  # considering mutual edges

#  Louvain method
community_louvain <- cluster_louvain(work_network_undirected)
plot(community_louvain, work_network_undirected)

"""Hierarchy and centralisation"""

# Betweenness centrality
betweenness_centrality <- betweenness(advice_network)

# Closeness centrality
closeness_centrality <- closeness(advice_network)

# Eigenvector centrality
eigenvector_centrality <- eigen_centrality(advice_network)$vector

"""identifying the Bridge nodes in the networks"""

# Nodes with high betweenness centrality can be considered as bridges
sorted_betweenness <- sort(betweenness_centrality, decreasing = TRUE)# identilfying the top ones

top_n_brokers <- head(sorted_betweenness, n = 10)
print(top_n_brokers)
